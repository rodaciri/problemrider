---
title: GraphQL Complexity Issues
description: GraphQL queries become too complex or expensive to execute, causing performance
  problems and potential denial-of-service vulnerabilities.
category:
- API Design
- Performance
- Security
related_problems:
- slug: algorithmic-complexity-problems
  similarity: 0.6
- slug: database-query-performance-issues
  similarity: 0.6
- slug: testing-complexity
  similarity: 0.55
- slug: complex-and-obscure-logic
  similarity: 0.55
- slug: high-number-of-database-queries
  similarity: 0.55
- slug: n-plus-one-query-problem
  similarity: 0.5
layout: problem
---

## Description

GraphQL complexity issues occur when queries become too expensive to execute due to deep nesting, large result sets, or computationally intensive resolvers. Without proper query complexity analysis and limits, GraphQL's flexibility can be exploited to create queries that consume excessive server resources, leading to performance degradation or denial-of-service conditions.

## Indicators ⟡

- GraphQL queries taking significantly longer to execute than expected
- Server resources consumed disproportionately by certain queries
- Memory usage spikes during GraphQL query execution
- Database queries generated from GraphQL becoming inefficient
- Client applications able to overload server with complex queries

## Symptoms ▲

- **Query Execution Timeouts:** Complex queries exceed execution time limits
- **Resource Exhaustion:** Queries consume excessive CPU, memory, or database connections
- **N+1 Query Problems:** GraphQL resolvers generating inefficient database query patterns
- **Deep Nesting Performance Issues:** Deeply nested queries causing exponential resource usage
- **Unbounded Result Sets:** Queries returning unexpectedly large amounts of data

## Root Causes ▼

- **Lack of Query Complexity Analysis:** No limits on query depth, breadth, or computational cost
- **Inefficient Resolver Implementation:** Resolvers not optimized for performance or using poor data fetching patterns
- **Missing Query Limits:** No pagination, timeouts, or result size limits on queries
- **Poor Schema Design:** GraphQL schema allowing unbounded or computationally expensive operations
- **Inadequate Caching:** Lack of caching at resolver or query level causing repeated expensive operations
- **Authorization at Wrong Level:** Security checks performed at field level instead of query planning level

## Detection Methods ○

- **Query Complexity Monitoring:** Monitor computational cost and resource usage of GraphQL queries
- **Resolver Performance Profiling:** Profile individual resolver execution times and resource usage
- **Database Query Analysis:** Analyze database queries generated by GraphQL execution
- **Query Depth and Breadth Analysis:** Track query structure complexity metrics
- **Resource Usage Correlation:** Correlate query patterns with server resource consumption

## Examples

An e-commerce GraphQL API allows clients to query product information with unlimited depth, enabling queries that fetch products with their categories, related products, reviews, and reviewer profiles recursively. A malicious or poorly designed client creates a query 10 levels deep that retrieves 50,000+ database records and consumes 2GB of memory, effectively creating a denial-of-service condition. Implementing query complexity analysis with depth limits and result pagination prevents resource exhaustion while maintaining API flexibility. Another example involves a social media GraphQL API where the friends resolver doesn't implement proper batching, causing N+1 query problems. A query fetching 100 users and their friends list generates 101 database queries instead of 2, making response times unacceptable. Implementing DataLoader for batch fetching reduces database queries by 98% and improves response times from 5 seconds to 200ms.