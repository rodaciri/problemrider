---
title: Inefficient Database Indexing
description: The database lacks appropriate indexes for common query patterns, forcing
  slow, full-table scans for data retrieval operations.
category:
- Data
- Performance
related_problems:
- slug: incorrect-index-type
  similarity: 0.85
- slug: queries-that-prevent-index-usage
  similarity: 0.75
- slug: unused-indexes
  similarity: 0.7
- slug: database-query-performance-issues
  similarity: 0.7
- slug: slow-database-queries
  similarity: 0.7
- slug: lazy-loading
  similarity: 0.7
layout: problem
---

## Description
Inefficient database indexing is a common cause of slow database queries. This can be caused by a variety of factors, from a lack of indexes on frequently queried columns to the use of the wrong type of index for the data. An effective indexing strategy is essential for ensuring that the database can retrieve data quickly and efficiently. This requires a deep understanding of the data, the queries that are being run, and the different types of indexes that are available.


## Indicators ⟡
- Queries are slow, even though they are running against a small amount of data.
- The database is using a full table scan, even though an index is available.
- The database is using a less efficient index than you expect it to use.
- The database is not using an index that you expect it to use.


## Symptoms ▲

- [Poor Caching Strategy](poor-caching-strategy.md) <span class="info-tooltip" title="Confidence: 0.371, Strength: 0.718">ⓘ</span>
<br/>  The lack of appropriate indexes leads to slow query performance, prompting the system to bypass caching mechanisms and retrieve data directly from the source on every request, which indicates an underlying issue with database efficiency.
- [Upstream Timeouts](upstream-timeouts.md) <span class="info-tooltip" title="Confidence: 0.331, Strength: 0.526">ⓘ</span>
<br/>  Slow, full-table scans due to inadequate indexing increase query response times, leading to API consumers experiencing timeouts as they wait longer than their configured thresholds for data retrieval.

## Root Causes ▼

- [Lazy Loading](lazy-loading.md) <span class="info-tooltip" title="Confidence: 0.396, Strength: 0.892">ⓘ</span>
<br/>  The excessive number of unnecessary database queries generated by lazy loading increases the demand for data retrieval, exposing the inefficiencies of the database's lack of appropriate indexing and exacerbating performance issues in legacy systems.
- [Slow Response Times for Lists](slow-response-times-for-lists.md) <span class="info-tooltip" title="Confidence: 0.395, Strength: 0.940">ⓘ</span>
<br/>  The slow loading times for pages displaying lists arise from frequent full-table scans due to the absence of optimized indexes, which, in turn, leads to the decision against implementing necessary indexing improvements in the database, perpetuating the inefficiency.
- [Insufficient Design Skills](insufficient-design-skills.md) <span class="info-tooltip" title="Confidence: 0.383, Strength: 0.954">ⓘ</span>
<br/>  The lack of experienced design skills leads to poorly structured database schemas without appropriate indexing strategies, resulting in inefficient data retrieval through slow, full-table scans.
- [Imperative Data Fetching Logic](imperative-data-fetching-logic.md) <span class="info-tooltip" title="Confidence: 0.380, Strength: 0.894">ⓘ</span>
<br/>  The application’s imperative data fetching logic leads to inefficient database indexing because it generates numerous repetitive queries that bypass the potential optimization of indexed access, resulting in the need for full-table scans and degraded performance.
- [External Service Delays](external-service-delays.md) <span class="info-tooltip" title="Confidence: 0.379, Strength: 0.921">ⓘ</span>
<br/>  Slow response times from external services lead to increased wait times for data retrieval, prompting developers to implement inadequate indexing strategies as a workaround to mitigate perceived performance issues.
- [High API Latency](high-api-latency.md) <span class="info-tooltip" title="Confidence: 0.379, Strength: 0.943">ⓘ</span>
<br/>  The excessive latency in API responses often leads developers to bypass optimal indexing practices in the database, resulting in reliance on inefficient full-table scans to meet immediate performance demands, which further compounds the application's slow performance.
- [Misunderstanding of OOP](misunderstanding-of-oop.md) <span class="info-tooltip" title="Confidence: 0.367, Strength: 0.934">ⓘ</span>
<br/>  A lack of understanding of object-oriented programming principles can result in poorly structured code that fails to identify and implement efficient indexing strategies, leading to inadequate database performance and slow data retrieval.
- [High Number of Database Queries](high-number-of-database-queries.md) <span class="info-tooltip" title="Confidence: 0.364, Strength: 0.927">ⓘ</span>
<br/>  The excessive number of database queries generated by single user requests overwhelms the system and exacerbates the existing issue of insufficient indexing, as the lack of targeted indexes leads to reliance on inefficient, full-table scans for each query, compounding performance issues in legacy environments.
- [Misconfigured Connection Pools](misconfigured-connection-pools.md) <span class="info-tooltip" title="Confidence: 0.357, Strength: 0.874">ⓘ</span>
<br/>  Improperly configured connection pools lead to frequent connection drops and timeouts, causing the application to resort to inefficient full-table scans instead of leveraging existing indexes for optimized data retrieval.
- [Shared Database](shared-database.md) <span class="info-tooltip" title="Confidence: 0.351, Strength: 0.936">ⓘ</span>
<br/>  The inefficiency in database indexing arises from multiple services competing for limited indexing resources in a shared database environment, leading to a lack of tailored indexes for specific query patterns and resulting in slow data retrieval.
- [Slow Application Performance](slow-application-performance.md) <span class="info-tooltip" title="Confidence: 0.328, Strength: 0.838">ⓘ</span>
<br/>  The sluggish user-facing features lead developers to prioritize immediate performance fixes over optimizing database indexing strategies, resulting in a reliance on inefficient full-table scans that degrade overall application performance.
- **Excessive Disk I/O**
- [Memory Swapping](memory-swapping.md) <span class="info-tooltip" title="Confidence: 0.316, Strength: 0.829">ⓘ</span>
<br/>  The lack of appropriate indexes leads to slow query performance, and when the database server runs out of physical memory and resorts to using disk swap space, it exacerbates this inefficiency by further increasing the time required for data retrieval operations, creating a vicious cycle of poor performance.
- [Long-Running Transactions](long-running-transactions.md) <span class="info-tooltip" title="Confidence: 0.304, Strength: 0.878">ⓘ</span>
<br/>  Long-running transactions can hold database locks that prevent timely indexing updates and optimizations, leading to a reliance on inefficient full-table scans for query execution.

## Detection Methods ○

- **Query Execution Plan Analysis:** Use the `EXPLAIN` or `EXPLAIN ANALYZE` command to see how the database is executing a query. Look for "Sequential Scan" or "Table Scan" on large tables, which indicates a missing index.
- **Database Indexing Advisors:** Many database systems have built-in tools or advisors that can analyze query history and suggest new indexes.
- **Monitoring Tools:** Use database monitoring tools to identify queries with high I/O and check if they are using appropriate indexes.
- **Manual Schema Review:** Manually inspect the database schema and compare the indexes with the most frequent and important query patterns in the application code.


## Examples
A user search feature in an application is very slow. The `users` table is indexed on the `id` column, but users are searched by their `email` address. Running `EXPLAIN` on the search query confirms that the database is performing a full table scan on the `users` table. Adding an index on the `email` column resolves the issue. In another case, a query like `SELECT * FROM orders WHERE YEAR(order_date) = 2023;` is slow even though there is an index on `order_date`. The use of the `YEAR()` function prevents the database from using the index directly. The query could be rewritten as `SELECT * FROM orders WHERE order_date >= '2023-01-01' AND order_date < '2024-01-01';` to allow the index to be used. This is a very common problem in legacy applications where new features and query patterns have been added over time without a corresponding review of the database indexing strategy.
