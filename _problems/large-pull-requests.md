---
title: Large Pull Requests
description: Pull requests are too large to review effectively, leading to superficial
  reviews and missed issues.
category:
- Code
- Communication
- Process
related_problems:
- slug: rushed-approvals
  similarity: 0.65
- slug: review-bottlenecks
  similarity: 0.6
- slug: large-feature-scope
  similarity: 0.6
- slug: reduced-code-submission-frequency
  similarity: 0.6
- slug: inadequate-code-reviews
  similarity: 0.6
- slug: excessive-class-size
  similarity: 0.55
layout: problem
---

## Description

Large pull requests occur when developers submit code changes that are too extensive or complex for reviewers to examine thoroughly within reasonable time constraints. These oversized changes make it practically impossible to conduct meaningful code reviews, as reviewers either skip the review entirely, perform only superficial checks, or approve changes without fully understanding their implications. Large pull requests defeat the primary purposes of code review: catching bugs, sharing knowledge, and maintaining code quality.


## Indicators ⟡
- Pull requests regularly contain hundreds or thousands of lines of changes
- Code reviews take an unusually long time or are approved very quickly without meaningful feedback
- Reviewers frequently comment "LGTM" (Looks Good To Me) without substantial review comments
- Developers avoid reviewing certain pull requests due to their size and complexity
- Multiple unrelated features or bug fixes are bundled together in single pull requests


## Symptoms ▲

*No significant relationships within the scope of legacy systems identified (yet).*

## Root Causes ▼

- [Gold Plating](gold-plating.md) <span class="info-tooltip" title="Confidence: 0.559, Strength: 0.866">ⓘ</span>
<br/>  The tendency to add unnecessary features and complexity to a project results in larger pull requests, which overwhelm reviewers and hinder effective code evaluation, ultimately leading to overlooked issues and diminished software quality in legacy systems.
- [Testing Complexity](testing-complexity.md) <span class="info-tooltip" title="Confidence: 0.522, Strength: 0.763">ⓘ</span>
<br/>  The need for quality assurance to verify overlapping functionality across multiple areas in legacy systems adds to the overall testing complexity, resulting in larger pull requests as developers bundle changes together to address extensive testing requirements, ultimately hindering thorough review processes.
- [Eager to Please Stakeholders](eager-to-please-stakeholders.md) <span class="info-tooltip" title="Confidence: 0.520, Strength: 0.753">ⓘ</span>
<br/>  The constant addition of new features and changes to satisfy stakeholder demands results in an expanded codebase that accumulates in large pull requests, making it difficult for reviewers to thoroughly assess the impact, leading to overlooked issues in the legacy system.
- [Bloated Class](bloated-class.md) <span class="info-tooltip" title="Confidence: 0.439, Strength: 0.844">ⓘ</span>
<br/>  The excessive size and complexity of a single class lead to substantial changes being bundled into pull requests, making them unwieldy and difficult for reviewers to dissect thoroughly, ultimately resulting in superficial assessments and overlooked defects.
- [High Number of Database Queries](high-number-of-database-queries.md) <span class="info-tooltip" title="Confidence: 0.427, Strength: 0.781">ⓘ</span>
<br/>  Excessive database queries generated by a single user request complicate the code changes required to optimize performance, resulting in larger pull requests that are difficult to review thoroughly and increasing the likelihood of overlooked issues.
- [Accumulation of Workarounds](accumulation-of-workarounds.md) <span class="info-tooltip" title="Confidence: 0.410, Strength: 0.678">ⓘ</span>
<br/>  The creation of elaborate workarounds to address unresolved core issues leads to increased complexity in the codebase, resulting in larger pull requests that overwhelm reviewers and hinder thorough evaluation.
- [Long Build and Test Times](long-build-and-test-times.md) <span class="info-tooltip" title="Confidence: 0.402, Strength: 0.720">ⓘ</span>
<br/>  Long build and test times discourage developers from making smaller, incremental changes, resulting in larger pull requests that are difficult to review thoroughly, leading to superficial evaluations and overlooked issues.
- [High Bug Introduction Rate](high-bug-introduction-rate.md) <span class="info-tooltip" title="Confidence: 0.389, Strength: 0.628">ⓘ</span>
<br/>  The introduction of a high rate of new bugs with each change leads to larger pull requests as developers pile on fixes and modifications to address ongoing quality issues, making thorough reviews impractical and increasing the likelihood of additional defects being overlooked.
- [Tangled Cross-Cutting Concerns](tangled-cross-cutting-concerns.md) <span class="info-tooltip" title="Confidence: 0.388, Strength: 0.808">ⓘ</span>
<br/>  Tightly coupled cross-cutting concerns inflate the size of code changes by intertwining multiple functional aspects, making pull requests cumbersome and difficult to review thoroughly, which ultimately leads to overlooked issues.
- [Large Estimates for Small Changes](large-estimates-for-small-changes.md) <span class="info-tooltip" title="Confidence: 0.382, Strength: 0.649">ⓘ</span>
<br/>  The tendency to provide inflated time estimates for minor changes reflects the underlying complexity and technical debt within the legacy code, resulting in larger pull requests that encompass more extensive modifications than anticipated, ultimately hindering effective review processes.
- [Perfectionist Culture](perfectionist-culture.md) <span class="info-tooltip" title="Confidence: 0.378, Strength: 0.810">ⓘ</span>
<br/>  A culture that prioritizes flawless code over timely releases results in extensive revisions and consolidation of changes, leading to large pull requests that overwhelm reviewers and compromise code quality.
- [Over-Reliance on Utility Classes](over-reliance-on-utility-classes.md) <span class="info-tooltip" title="Confidence: 0.368, Strength: 0.816">ⓘ</span>
<br/>  The use of an excessive number of utility classes with static methods leads to a procedural programming style that encourages monolithic code changes, resulting in large pull requests that are difficult to review thoroughly and often overlook critical issues.
- [Rapid System Changes](rapid-system-changes.md) <span class="info-tooltip" title="Confidence: 0.363, Strength: 0.613">ⓘ</span>
<br/>  Frequent changes to system architecture and core functionality lead to larger pull requests as developers attempt to implement multiple updates simultaneously, resulting in overwhelming complexity that hinders effective code review and increases the likelihood of overlooked issues.
- [Misunderstanding of OOP](misunderstanding-of-oop.md) <span class="info-tooltip" title="Confidence: 0.347, Strength: 0.870">ⓘ</span>
<br/>  A lack of understanding of object-oriented programming principles often results in monolithic and tightly coupled code structures, which can lead to extensive changes being bundled into large pull requests that are unwieldy for reviewers to analyze effectively.
- [Insufficient Design Skills](insufficient-design-skills.md) <span class="info-tooltip" title="Confidence: 0.331, Strength: 0.889">ⓘ</span>
<br/>  The lack of adequate design skills results in poorly structured code that accumulates in large pull requests, making it difficult for reviewers to identify issues and leading to ineffective code reviews.
- [Clever Code](clever-code.md) <span class="info-tooltip" title="Confidence: 0.314, Strength: 0.591">ⓘ</span>
<br/>  The tendency to write overly complex code increases the size of pull requests, as intricate implementations require more lines of code and obscure functionality, making thorough review challenging and leading to overlooked issues in legacy systems.
- [Increasing Brittleness](increasing-brittleness.md) <span class="info-tooltip" title="Confidence: 0.306, Strength: 0.703">ⓘ</span>
<br/>  As software systems age and become more fragile, the complexity and interdependencies of the codebase increase, resulting in larger pull requests that encompass numerous changes and make thorough reviews difficult, ultimately leading to overlooked issues.
- [Feature Creep](feature-creep.md) <span class="info-tooltip" title="Confidence: 0.301, Strength: 0.587">ⓘ</span>
<br/>  The gradual expansion of features leads to increased complexity and size of code changes, resulting in larger pull requests that overwhelm reviewers and compromise the quality of code evaluations.

## Detection Methods ○
- **Pull Request Size Metrics:** Track lines of code changed, files modified, and complexity metrics for pull requests
- **Review Time Analysis:** Monitor how long reviews take and correlate with pull request size
- **Review Quality Assessment:** Analyze the depth and quality of feedback provided on different sized pull requests
- **Approval Patterns:** Identify pull requests that are approved quickly relative to their size
- **Developer Feedback:** Ask team members about their experience reviewing large pull requests


## Examples

A developer works on implementing a new user authentication system for three weeks in isolation. When they finally submit the pull request, it contains 2,500 lines of new code across 45 files, including database schema changes, new API endpoints, frontend components, configuration updates, and documentation changes. The assigned reviewers look at the massive pull request and either provide minimal feedback ("looks good overall") or focus only on obvious issues like code formatting, missing obvious bugs and architectural problems. Due to the size, no reviewer has the time or energy to understand the complete authentication flow, verify that security requirements are met, or ensure the implementation follows established patterns. Several critical security vulnerabilities make it into production because they were buried within the large changeset. Another example involves a pull request that combines a major refactoring of the data access layer with three new features and bug fixes for two existing features. The 1,800-line pull request spans multiple business domains and requires expertise in different areas of the system. Reviewers focus on the parts they understand best and skip areas outside their expertise, resulting in integration issues and inconsistent code quality across the different changes.
