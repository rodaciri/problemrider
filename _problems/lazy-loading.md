---
title: Lazy Loading
description: The use of lazy loading in an ORM framework leads to a large number of
  unnecessary database queries, which can significantly degrade application performance.
category:
- Code
- Data
- Performance
related_problems:
- slug: imperative-data-fetching-logic
  similarity: 0.75
- slug: high-number-of-database-queries
  similarity: 0.7
- slug: n-plus-one-query-problem
  similarity: 0.7
- slug: slow-database-queries
  similarity: 0.7
- slug: inefficient-database-indexing
  similarity: 0.7
- slug: incorrect-index-type
  similarity: 0.65
layout: problem
---

## Description
Lazy loading is a design pattern that is used to defer the initialization of an object until it is actually needed. This can be a useful pattern in some cases, but it can also lead to performance problems. In the context of an object-relational mapping (ORM) framework, lazy loading can lead to the N+1 query problem. This is because the ORM will execute a separate query for each object that is lazily loaded. This can result in a large number of unnecessary database queries, which can significantly degrade application performance.


## Indicators ⟡
- The application is making a large number of small, fast queries instead of a few larger, slower queries.
- The application is slow, even though the database server is not under heavy load.
- The database logs are full of similar-looking queries.
- The application is using an ORM framework, and you are not sure if it is configured correctly.


## Symptoms ▲

- [Upstream Timeouts](upstream-timeouts.md) <span class="info-tooltip" title="Confidence: 0.676, Strength: 0.864">ⓘ</span>
<br/>  Excessive database queries caused by inefficient data retrieval practices lead to increased response times, resulting in upstream services timing out due to their inability to receive timely API responses.
- [Inefficient Development Environment](inefficient-development-environment.md) <span class="info-tooltip" title="Confidence: 0.602, Strength: 0.900">ⓘ</span>
<br/>  The excessive database queries caused by lazy loading result in prolonged response times and decreased performance, which in turn frustrates developers and hinders their productivity in a legacy system's development environment.
- [Poor Caching Strategy](poor-caching-strategy.md) <span class="info-tooltip" title="Confidence: 0.486, Strength: 0.872">ⓘ</span>
<br/>  The excessive database queries from lazy loading lead to frequent data retrieval, making it evident that a poor caching strategy is in place, as the same data is repeatedly fetched instead of being stored for quicker access, exacerbating performance issues in legacy systems.
- [Queries That Prevent Index Usage](queries-that-prevent-index-usage.md) <span class="info-tooltip" title="Confidence: 0.485, Strength: 0.828">ⓘ</span>
<br/>  The excessive database queries generated by lazy loading often result in poorly structured or inefficiently written queries, which can prevent the use of available indexes, leading to slower performance in legacy systems.
- [Unreleased Resources](unreleased-resources.md) <span class="info-tooltip" title="Confidence: 0.477, Strength: 0.897">ⓘ</span>
<br/>  Excessive and repetitive database queries stemming from the use of lazy loading can lead to the allocation of numerous temporary objects and connections that are not properly released, resulting in unreleased resources that indicate underlying inefficiencies in resource management within the system.
- [Inadequate Test Data Management](inadequate-test-data-management.md) <span class="info-tooltip" title="Confidence: 0.438, Strength: 0.915">ⓘ</span>
<br/>  The excessive database queries triggered by the inefficient loading mechanism expose inadequacies in test data management, as the unrealistic or insufficient data fails to simulate the high load scenarios that would reveal performance issues during testing.
- [Inefficient Code](inefficient-code.md) <span class="info-tooltip" title="Confidence: 0.413, Strength: 0.865">ⓘ</span>
<br/>  The excessive database queries triggered by lazy loading result in increased response times, which in turn exposes performance bottlenecks in the request-handling code, making inefficient code a direct symptom of the underlying lazy loading issue.
- [Delayed Bug Fixes](delayed-bug-fixes.md) <span class="info-tooltip" title="Confidence: 0.411, Strength: 0.858">ⓘ</span>
<br/>  The excessive database queries caused by the inefficient use of lazy loading often lead to performance bottlenecks, which can obscure the detection of underlying issues, resulting in delayed bug fixes as developers struggle to prioritize and address performance-related problems amidst ongoing user frustration.
- [Inefficient Database Indexing](inefficient-database-indexing.md) <span class="info-tooltip" title="Confidence: 0.396, Strength: 0.892">ⓘ</span>
<br/>  The excessive database queries generated by lazy loading exacerbate the impact of inefficient indexing, as each unnecessary query triggers full-table scans that would be mitigated with proper indexes, highlighting the performance degradation in legacy systems.
- [Monolithic Architecture Constraints](monolithic-architecture-constraints.md) <span class="info-tooltip" title="Confidence: 0.393, Strength: 0.831">ⓘ</span>
<br/>  The excessive database queries generated by lazy loading in a complex, monolithic codebase result in performance bottlenecks, making it harder to maintain and scale the system effectively, thus indicating deeper architectural issues.
- [Negative User Feedback](negative-user-feedback.md) <span class="info-tooltip" title="Confidence: 0.372, Strength: 0.830">ⓘ</span>
<br/>  The excessive database queries triggered by inefficient loading strategies result in slow response times, leading users to express dissatisfaction through complaints about performance issues.
- [Deadline Pressure](deadline-pressure.md) <span class="info-tooltip" title="Confidence: 0.368, Strength: 0.874">ⓘ</span>
<br/>  Rushed development cycles often lead teams to implement lazy loading without proper optimization, resulting in excessive database queries that hinder application performance and reflect a compromised focus on quality due to looming deadlines.
- [Incorrect Max Connection Pool Size](incorrect-max-connection-pool-size.md) <span class="info-tooltip" title="Confidence: 0.348, Strength: 0.878">ⓘ</span>
<br/>  Excessive unnecessary database queries due to inefficient data loading can quickly saturate the available connections in a pool, leading to poor resource management and potential connection exhaustion, which serves as an indicator of underlying performance issues in legacy systems.
- [Unused Indexes](unused-indexes.md) <span class="info-tooltip" title="Confidence: 0.341, Strength: 0.854">ⓘ</span>
<br/>  The excessive database queries triggered by inefficient loading patterns can lead to the creation of indexes that are never utilized, as the application architecture fails to optimize query performance, indicating a deeper issue with resource management in legacy systems.
- [High Resource Utilization on Client](high-resource-utilization-on-client.md) <span class="info-tooltip" title="Confidence: 0.339, Strength: 0.851">ⓘ</span>
<br/>  Excessive database queries due to inefficient data retrieval strategies lead to increased data processing on the client side, resulting in high resource utilization that negatively impacts performance, especially on legacy systems with limited processing capabilities.
- [Unoptimized File Access](unoptimized-file-access.md) <span class="info-tooltip" title="Confidence: 0.329, Strength: 0.892">ⓘ</span>
<br/>  Inefficient file access occurs as a symptom of excessive database queries from lazy loading, as the application attempts to compensate for the multiple round trips to the database by engaging in heavy read/write operations, ultimately leading to increased disk I/O and degraded performance.
- [Poor Domain Model](poor-domain-model.md) <span class="info-tooltip" title="Confidence: 0.324, Strength: 0.892">ⓘ</span>
<br/>  The reliance on lazy loading due to a poorly defined domain model results in excessive database queries, as the system fails to optimize data retrieval based on actual business needs, indicating a fundamental misunderstanding of core business concepts.
- [High Defect Rate in Production](high-defect-rate-in-production.md) <span class="info-tooltip" title="Confidence: 0.320, Strength: 0.793">ⓘ</span>
<br/>  The excessive database queries caused by inefficient data retrieval strategies can lead to performance bottlenecks that complicate testing and increase the likelihood of defects in production, as developers may overlook performance-related issues during the quality assurance process.
- [Incorrect Index Type](incorrect-index-type.md) <span class="info-tooltip" title="Confidence: 0.317, Strength: 0.866">ⓘ</span>
<br/>  The excessive database queries resulting from lazy loading can lead to the use of incorrect index types as a symptom, since the increased load often forces developers to optimize performance without fully addressing the underlying query inefficiencies, ultimately compounding the data retrieval issues in legacy systems.
- [Feature Creep](feature-creep.md) <span class="info-tooltip" title="Confidence: 0.313, Strength: 0.887">ⓘ</span>
<br/>  The excessive database queries caused by lazy loading can lead to an overcomplicated feature set as developers continuously add new functionalities to manage performance issues, resulting in a bloated system that becomes increasingly challenging to maintain.
- [High Client-Side Resource Consumption](high-client-side-resource-consumption.md) <span class="info-tooltip" title="Confidence: 0.309, Strength: 0.890">ⓘ</span>
<br/>  Excessive database queries triggered by lazy loading result in increased data processing on the client-side, leading to high resource consumption and degraded performance.

## Root Causes ▼

*No significant relationships within the scope of legacy systems identified (yet).*

## Detection Methods ○
- **Application Performance Monitoring (APM):** APM tools can often detect and flag the N+1 query problem, which is a common symptom of lazy loading.
- **SQL Logging:** Enable SQL logging in your application or database and inspect the logs for a large number of similar-looking queries.
- **Code Review:** During code reviews, specifically look for code that is using lazy loading.
- **ORM Profiling:** Some ORM frameworks provide tools for profiling the performance of your queries.


## Examples
A web application is using an ORM framework to fetch data from the database. The application has a page that displays a list of users and their posts. The application is using lazy loading to fetch the posts for each user. This means that the application first executes a query to get the list of users. Then, for each user, it executes another query to get their posts. This results in a large number of unnecessary database queries, which makes the page slow to load. The problem could be solved by using eager loading to fetch the users and their posts in a single query.
